using System;
using System.Collections.Generic;
using System.Reflection;
using System.Reflection.Emit;
using System.Threading;

namespace NewRemoting.Toolkit
{
	/// <summary>
	/// This is used to provide improved event mechanism which removes some  pitfalls of normal c# events.
	/// 1. A normal c# event stores a normal reference to a event subscriber. This can lead to memory leaks if a client does not unsubscribe.
	///    This class does only store a weak reference to the subscriber.
	///
	/// 2.  All invocation targets are executed if one throws an exceptions
	///
	/// To use this class, define the event type as generic argument and implement the add and remove method of the event manually.
	/// </summary>
	internal class WeakEvent<T> : WeakEventBase, IWeakEventInvoker, IWeakEvent<T>
		where T : class
	{
		protected readonly object _eventEntriesReadLock;
		private readonly object _eventEntriesModifiyLock;
		private readonly T _raiser;
		private readonly Action<AggregateException> _onException;
		protected readonly IWeakEventInvoker _invoker;

		private List<WeakEventEntry> _eventEntries = new List<WeakEventEntry>();

		/// <summary>
		/// Static ctor for WeakEvent
		/// </summary>
		/// <exception cref="ArgumentException">T must be a delegate and the return type must be void</exception>
		static WeakEvent()
		{
			if (!typeof(T).IsSubclassOf(typeof(Delegate)))
			{
				throw new ArgumentException("T must be a delegate type");
			}

			MethodInfo invoke = typeof(T).GetMethod("Invoke");

			if (invoke.ReturnType != typeof(void))
			{
				throw new ArgumentException("The delegate return type must be void.");
			}
		}

		/// <summary>
		/// Creates a new WeakEvent
		/// </summary>
		/// <param name="onException">If not null, thre raise mthod does not throw an exception, this action is called instead</param>
		/// <param name="invoker">Invoker implementation which handles each invokartion of a target</param>
		internal WeakEvent(Action<AggregateException> onException, IWeakEventInvoker invoker)
		{
			_invoker = invoker ?? this;
			_onException = onException;
			_raiser = CreateRaiser();
			_eventEntriesReadLock = new object();
			_eventEntriesModifiyLock = new object();
		}

		public int ClientCount
		{
			get
			{
				return _eventEntries.Count;
			}
		}

		/// <summary>
		/// This property is used like a method, to provide a type safe raiser. This is required because it is
		/// not possible to declare a Delegate as a constraint
		/// </summary>
		public T Raise
		{
			get
			{
				return _raiser;
			}
		}

		/// <summary>
		/// This method is called by the raiser generated by "CreateRaiser"
		/// </summary>
		/// <exception cref="AggregateException">One or more exeptions occured in event handlers</exception>
		protected void RaiseInternal(object[] arguments)
		{
			AggregateException aggregateException;
			bool removeRequired = false;
			lock (_eventEntriesReadLock)
			{
				removeRequired = InvokeTargets(arguments, _eventEntries, out aggregateException);
			}

			if (removeRequired)
			{
				RemoveInvalidEntries();
			}

			if (aggregateException != null && !FireAggregateException(aggregateException))
			{
				throw aggregateException;
			}
		}

		protected virtual bool FireAggregateException(AggregateException aggregateException)
		{
			if (_onException != null)
			{
				_onException(aggregateException);
				return true;
			}

			return false;
		}

		protected virtual bool InvokeTargets(object[] arguments, List<WeakEventEntry> eventEntries, out AggregateException aggregateException)
		{
			bool removalRequired = false;
			List<Exception> exceptions = null;
			aggregateException = null;
			foreach (var eventEntry in eventEntries)
			{
				try
				{
					if (_invoker.InvokeTarget(eventEntry, arguments)) // if the invoke was not executed, the target reference has been collected
					{
						removalRequired = true;
					}
				}
				catch (Exception ex)
				{
					if (exceptions == null)
					{
						exceptions = new List<Exception>();
					}

					exceptions.Add(ex);
				}
			}

			if (exceptions != null)
			{
				aggregateException = new AggregateException(exceptions);
			}

			return removalRequired;
		}

		public bool InvokeTarget(WeakEventEntry target, object[] arguments)
		{
			bool removalRequired = !target.Invoke(arguments);
			return removalRequired;
		}

		/// <summary>
		/// Adds a subscriber
		/// </summary>
		public void Add(T invocationTarget)
		{
			Delegate del = invocationTarget as Delegate;
			if (del != null)
			{
				MethodInfo targetMethod = del.Method;
				object targetInstance = del.Target;

				WeakEventEntry entry = new WeakEventEntry(CreateInvoker(targetMethod), targetMethod, targetInstance);
				lock (_eventEntriesModifiyLock)
				{
					bool hasReadLock = Monitor.TryEnter(_eventEntriesReadLock);
					List<WeakEventEntry> localCopy = hasReadLock ? _eventEntries : new List<WeakEventEntry>(_eventEntries); // only copy the list if InvokeTargets is running
					localCopy.Add(entry);
					_eventEntries = localCopy;
					if (hasReadLock)
					{
						Monitor.Exit(_eventEntriesReadLock);
					}
				}
			}
		}

		/// <summary>
		/// Removes a subscriber
		/// </summary>
		public void Remove(T eh)
		{
			if (eh != null)
			{
				Delegate d = (Delegate)(object)eh;
				object targetInstance = d.Target;
				MethodInfo targetMethod = d.Method;
				lock (_eventEntriesModifiyLock)
				{
					bool hasReadLock = Monitor.TryEnter(_eventEntriesReadLock);
					List<WeakEventEntry> localCopy = hasReadLock ? _eventEntries : new List<WeakEventEntry>(_eventEntries); // only copy the list if InvokeTargets is running
					for (int i = 0; i < localCopy.Count; i++)
					{
						if (localCopy[i].IsInvalid)
						{
							localCopy.RemoveAt(i);
							i--;
						}
						else if (localCopy[i].Matches(targetInstance, targetMethod))
						{
							localCopy.RemoveAt(i);
							break;
						}
					}

					_eventEntries = localCopy;
					if (hasReadLock)
					{
						Monitor.Exit(_eventEntriesReadLock);
					}
				}
			}
		}

		public void RemoveAll()
		{
			lock (_eventEntriesModifiyLock)
			{
				_eventEntries = new List<WeakEventEntry>();
			}
		}

		protected void RemoveInvalidEntries()
		{
			lock (_eventEntriesModifiyLock)
			{
				for (int i = 0; i < _eventEntries.Count; i++)
				{
					if (_eventEntries[i].IsInvalid)
					{
						_eventEntries.RemoveAt(i);
						i--;
					}
				}
			}
		}

		/// <summary>
		/// Creates a method with the signature of T, to invoke the RaiseInternal method with the passed arguments.
		/// This is required, because it is not allowed to to define a delegate as constraint
		/// </summary>
		internal T CreateRaiser()
		{
			Type delgateType = typeof(T);

			var invokeParameterInfos = delgateType.GetMethod("Invoke").GetParameters();
			Type[] raiserArgumentTypes = new Type[invokeParameterInfos.Length + 1];
			raiserArgumentTypes[0] = GetType(); // the fist argument type is WeakEvent (this) pointer
			for (int i = 0; i < invokeParameterInfos.Length; i++)
			{
				raiserArgumentTypes[i + 1] = invokeParameterInfos[i].ParameterType;
			}

			DynamicMethod dm = new DynamicMethod(string.Empty, null, raiserArgumentTypes, GetType());

			ILGenerator il = dm.GetILGenerator();

			il.DeclareLocal(typeof(object[]));

			il.Emit(OpCodes.Ldarg_0); // load this on stack for later method call
			il.Emit(OpCodes.Ldc_I4_S, invokeParameterInfos.Length); // load the parameter length
			il.Emit(OpCodes.Newarr, typeof(object));
			il.Emit(OpCodes.Stloc_0); // store the new array

			for (int i = 0; i < invokeParameterInfos.Length; i++)
			{
				il.Emit(OpCodes.Ldloc_0); // load the array
				il.Emit(OpCodes.Ldc_I4_S, i); // load index on stack to assigning array index to parameter
				il.Emit(OpCodes.Ldarg_S, i + 1); // load first argument. 0 is this pointer
				if (raiserArgumentTypes[i + 1].IsValueType)
				{
					il.Emit(OpCodes.Box, raiserArgumentTypes[i + 1]); // i + 1 because the fist argument type is WeakEvent (this) pointer
				}

				il.Emit(OpCodes.Stelem_Ref);
			}

			il.Emit(OpCodes.Ldloc_0); // load array on the stack

			il.EmitCall(OpCodes.Call, GetType().GetMethod(nameof(RaiseInternal), BindingFlags.NonPublic | BindingFlags.Instance), null);

			il.Emit(OpCodes.Ret);
			return dm.CreateDelegate(delgateType, this) as T;
		}
	}
}
